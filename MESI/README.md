# ğŸ§  MESI-Based Cache Coherence System

This project implements a 2-core MESI (Modified, Exclusive, Shared, Invalid) cache coherence protocol in SystemVerilog along with a functional SystemVerilog testbench for simulation and coverage.

Each cache controller operates as a finite state machine (FSM), responding to read/write requests and snoop signals. The system simulates realistic coherence behavior in a shared-memory multicore architecture.

---

## ğŸ§© Interface Overview

The design communicates using a shared memory interface and supports multiple cores (parameterized):

| Signal Name      | Direction | Description                                 |
|------------------|-----------|---------------------------------------------|
| `read_req`       | Input     | Per-core read requests                      |
| `write_req`      | Input     | Per-core write requests                     |
| `addr`           | Input     | Address each core is accessing              |
| `mem_read`       | Output    | Memory read trigger                         |
| `mem_write`      | Output    | Memory write trigger                        |
| `state`          | Output    | Current MESI state of each cache line       |
| `clk`, `rst`     | Input     | Clock and asynchronous reset                |

---

## ğŸ—‚ Coherence State Encoding

| State  | Code   | Description                                                   |
|--------|--------|---------------------------------------------------------------|
| `I`    | `2'b00`| Invalid - No valid data; must fetch from memory               |
| `S`    | `2'b01`| Shared - Valid data; possibly shared with others              |
| `E`    | `2'b10`| Exclusive - Valid data; only copy in system                   |
| `M`    | `2'b11`| Modified  - Only copy; has been modified; must be flushed     |

---

## ğŸ” State Transitions

Some key examples:
- `INVALID â†’ EXCLUSIVE` when a read occurs and no one else has the data
- `SHARED â†’ MODIFIED` on a write
- `MODIFIED â†’ SHARED/INVALID` on snoop read/snoop exclusive
- Snoop signals are generated by checking address conflicts across caches


---

## ğŸ§ª SystemVerilog Testbench

The current testbench is written in pure SystemVerilog, without UVM. It includes:

- Clock/reset generation
- Functional stimulus for 10 MESI transition scenarios
- Live state monitoring using `$monitor`
- Covergroups to capture per-core MESI state transitions
- Transition filtering based on address match

This setup allows simulation and analysis of cache coherence correctness across two cores.

---

## ğŸ“Š Coverage Analysis

Covergroups track MESI transitions:

- `I â†’ E`, `I â†’ S`, `E â†’ M`, `S â†’ M`, etc.
- Coverage is conditional: sampled only when the same address is reused with a changed state

---
## ğŸ”’ Protocol Assertions (SVA)

Assertions embedded in the interface (`mesi_if.sv`) verify key MESI transitions:

âœ… Read miss from Invalid must go to E/S  
âœ… Modified state is unique per address  
âœ… Shared state must imply another sharer  
âœ… Transitions like `Iâ†’E`, `Iâ†’S`, `Sâ†’M`, `Eâ†’M`, `Mâ†’I`, etc. are enforced  
âœ… Snoop-based invalidation and sharing transitions are monitored

This guards against protocol violations during simulation and improves confidence in design correctness.

---

## ğŸ“¦ What's Included

| File                | Description                                  |
|---------------------|----------------------------------------------|
| `top_system.sv`     | Top-level module managing N cache FSMs       |
| `cache_controller.sv` | Implements MESI FSM per cache              |
| `mesi_if.sv`        | Parameterized interface for design hooks     |
| `testbench.sv`      | SystemVerilog testbench + coverage tracking  |

---

## ğŸ”§ **Running the Testbench**  

To compile and run this testbench, follow the **general simulation setup** provided in the **[UVM README](../README.md)**.  

ğŸ”— **UVM Repository Simulation Guide**: [Click here](../README.md)  

---

## ğŸ¤ Contributing

Interested in improving or extending this project (e.g., MOESI support or memory model)?  
Feel free to fork and submit a pull request!

