# 🧠 MESI-Based Cache Coherence System

This project implements a 2-core MESI (Modified, Exclusive, Shared, Invalid) cache coherence protocol in SystemVerilog along with a functional SystemVerilog testbench for simulation and coverage.

Each cache controller operates as a finite state machine (FSM), responding to read/write requests and snoop signals. The system simulates realistic coherence behavior in a shared-memory multicore architecture.

---

## 🧩 Interface Overview

The design communicates using a shared memory interface and supports multiple cores (parameterized):

| Signal Name      | Direction | Description                                 |
|------------------|-----------|---------------------------------------------|
| `read_req`       | Input     | Per-core read requests                      |
| `write_req`      | Input     | Per-core write requests                     |
| `addr`           | Input     | Address each core is accessing              |
| `mem_read`       | Output    | Memory read trigger                         |
| `mem_write`      | Output    | Memory write trigger                        |
| `state`          | Output    | Current MESI state of each cache line       |
| `clk`, `rst`     | Input     | Clock and asynchronous reset                |

---

## 🗂 Coherence State Encoding

| State  | Code   | Description                                                   |
|--------|--------|---------------------------------------------------------------|
| `I`    | `2'b00`| Invalid - No valid data; must fetch from memory               |
| `S`    | `2'b01`| Shared - Valid data; possibly shared with others              |
| `E`    | `2'b10`| Exclusive - Valid data; only copy in system                   |
| `M`    | `2'b11`| Modified  - Only copy; has been modified; must be flushed     |

---

## 🔁 State Transitions

Some key examples:
- `INVALID → EXCLUSIVE` when a read occurs and no one else has the data
- `SHARED → MODIFIED` on a write
- `MODIFIED → SHARED/INVALID` on snoop read/snoop exclusive
- Snoop signals are generated by checking address conflicts across caches


---

## 🧪 SystemVerilog Testbench

The current testbench is written in pure SystemVerilog, without UVM. It includes:

- Clock/reset generation
- Functional stimulus for 10 MESI transition scenarios
- Live state monitoring using `$monitor`
- Covergroups to capture per-core MESI state transitions
- Transition filtering based on address match

This setup allows simulation and analysis of cache coherence correctness across two cores.

---

## 📊 Coverage Analysis

Covergroups track MESI transitions:

- `I → E`, `I → S`, `E → M`, `S → M`, etc.
- Coverage is conditional: sampled only when the same address is reused with a changed state

---
## 🔒 Protocol Assertions (SVA)

Assertions embedded in the interface (`mesi_if.sv`) verify key MESI transitions:

✅ Read miss from Invalid must go to E/S  
✅ Modified state is unique per address  
✅ Shared state must imply another sharer  
✅ Transitions like `I→E`, `I→S`, `S→M`, `E→M`, `M→I`, etc. are enforced  
✅ Snoop-based invalidation and sharing transitions are monitored

This guards against protocol violations during simulation and improves confidence in design correctness.

---

## 📦 What's Included

| File                | Description                                  |
|---------------------|----------------------------------------------|
| `top_system.sv`     | Top-level module managing N cache FSMs       |
| `cache_controller.sv` | Implements MESI FSM per cache              |
| `mesi_if.sv`        | Parameterized interface for design hooks     |
| `testbench.sv`      | SystemVerilog testbench + coverage tracking  |

---

## 🔧 **Running the Testbench**  

To compile and run this testbench, follow the **general simulation setup** provided in the **[UVM README](../README.md)**.  

🔗 **UVM Repository Simulation Guide**: [Click here](../README.md)  

---

## 🤝 Contributing

Interested in improving or extending this project (e.g., MOESI support or memory model)?  
Feel free to fork and submit a pull request!

